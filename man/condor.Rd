% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/condor.R
\name{condor}
\alias{condor}
\title{Wrapper for core condor functions}
\usage{
condor(edgelist, return.gcc = TRUE, cs.method = "LCS", project = TRUE,
  norm = TRUE)
}
\arguments{
\item{edgelist}{a data.frame with 'red' nodes in the first column and
'blue' nodes in the second column, representing links from the node in
the first column to the node in the second column. There must be more
unique 'red' nodes than 'blue' nodes. Optionally, a third column may be
provided to create a weighted network.}

\item{return.gcc}{if TRUE, returns the giant connected component}

\item{cs.method}{is a string to specify which unipartite community 
structure algorithm should be used for the seed clustering. 
Options are \code{LCS} (\code{\link[igraph]{multilevel.community}}), 
\code{LEC} (\code{\link[igraph]{leading.eigenvector.community}}), 
\code{FG} (\code{\link[igraph]{fastgreedy.community}}).}

\item{project}{Provides options for initial seeding of the bipartite 
modularity maximization.
If TRUE, the nodes in the first column of \code{condor.object$edges} 
are projected and clustered using \code{cs.method}. If FALSE, the 
complete bipartite network is clustered using the unipartite clustering 
methods listed in \code{cs.method}.}

\item{norm}{TRUE/FALSE - if TRUE, normalize core score by community modularity}
}
\value{
\code{condor.object}
}
\description{
Given an input edge list, this function performs community structure clustering and
calculates core scores.
}
\examples{
r = c(1,1,1,2,2,2,3,3,3,4,4);
b = c(1,2,3,1,2,4,2,3,4,3,4);
reds <- c("Alice","Sue","Janine","Mary")
blues <- c("Bob","John","Ed","Hank")
elist <- data.frame(red=reds[r],blue=blues[b])
condor.object <- condor(elist)
}

